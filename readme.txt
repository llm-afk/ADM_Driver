═══════════════════════════════════════════════════════════════════════════
📍 DSP上电启动完整流程详解（从硬件复位到main函数）
═══════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────┐
│ 步骤1: 🔌 硬件上电复位 (Power-On Reset)                                  
└─────────────────────────────────────────────────────────────────────────┘
│
│ 触发条件:
│ • 外部复位引脚XRSn拉低
│ • 上电复位（POR）
│ • 看门狗复位
│ • 软件复位
│
│ 硬件行为:
│ • CPU所有寄存器强制复位到初始值
│ • 程序计数器(PC)被硬件强制设置为复位向量地址
│ • 所有外设进入复位状态
│ • RAM内容未定义（可能是随机值或保持上次的值）
│ • 看门狗处于使能状态（如果不及时关闭会再次复位）
│
▼

┌─────────────────────────────────────────────────────────────────────────┐
│ 步骤2: 🏛️ Boot ROM执行 (芯片固化的引导程序)                               
│ 地址: 0x3FF27C (Boot ROM代码起始地址，芯片出厂时固化，不可修改)             
└─────────────────────────────────────────────────────────────────────────┘
│
│ Boot ROM的详细操作流程:
│
│ 1. 初始化基本硬件:
│ • 配置系统时钟（使用内部或外部晶振）
│ • 初始化基本外设寄存器
│ • 设置CPU工作模式
│
│ 2. 检查GPIO引脚状态（决定引导模式）:
│ • 读取特定GPIO引脚的电平
│ • 根据引脚组合决定引导方式:
│ - Flash引导模式: 从Flash启动（最常见）
│ - SCI引导模式: 通过串口下载程序
│ - SPI引导模式: 通过SPI接口引导
│ - 其他引导模式...
│
│ 3. 检查CSM（代码安全模块）状态:
│ • 读取CSM密码区域地址: 0x3F7FF8 ~ 0x3F7FFF
│ • 如果密码不是0xFFFF（全1），说明CSM已启用
│ • 需要执行CSM解锁操作（读取密码寄存器）
│ • 如果密码是0xFFFF，CSM未启用，直接继续
│
│ 4. 根据引导模式选择入口地址:
│ • Flash引导模式 → 跳转到BEGIN地址 (0x3F7FF6)
│ • SCI引导模式 → 执行SCI Bootloader
│ • 其他模式 → 相应处理
│
│ 5. 执行跳转:
│ • 将程序计数器(PC)设置为目标地址
│ • 开始执行用户程序
│
▼

┌─────────────────────────────────────────────────────────────────────────┐
│ 步骤3: 🎯 BEGIN地址检查与跳转 (硬件固定入口点)                             
│ 地址: 0x3F7FF6 (硬件固定，Boot ROM必须检查这个地址！)                      
└─────────────────────────────────────────────────────────────────────────┘
│
│ 重要说明:
│ • 0x3F7FF6是TI C2000 DSP硬件设计时固定的地址
│ • Boot ROM的代码中硬编码了这个地址（不可改变）
│ • 用户不能修改这个地址，只能在这个地址放置代码
│ • BEGIN只是给这个地址起的符号名，方便引用
│
│ Boot ROM的操作:
│ 1. 读取0x3F7FF6地址的内容（2 words = 4 bytes）
│ 2. 验证是否为有效的跳转指令
│ 3. 如果有效，将PC设置为0x3F7FF6，开始执行
│ 4. 如果无效（全0或全1），可能进入其他引导模式或错误处理
│
│ 这个地址的内容（由链接器放置）:
│ • .sect "codestart" 段被链接器放到BEGIN地址
│ • code_start标签在这个段中
│ • code_start包含一条指令: LB main_init
│
▼

┌─────────────────────────────────────────────────────────────────────────┐
│ 步骤4: 🚀 code_start执行 (在BEGIN地址，只有一条跳转指令)                   
│ 地址: 0x3F7FF6                                                           
│ 代码: LB main_init (长跳转指令，跳转到main_init函数)                       
└─────────────────────────────────────────────────────────────────────────┘
│
│ 执行过程:
│ 1. CPU从0x3F7FF6读取指令: LB main_init
│ 2. 解析跳转目标地址（main_init在.text段中的地址，约0x3E8000+）
│ 3. 计算相对偏移量或绝对地址
│ 4. 更新程序计数器(PC)到main_init地址
│ 5. 开始执行main_init函数
│
│ 注意:
│ • 这是唯一在BEGIN地址的代码
│ • 只有一条跳转指令（2 words = 4 bytes）
│ • 必须在这个固定地址，Boot ROM才能找到
│ • 跳转后，CPU开始执行.text段中的代码
│
▼

┌─────────────────────────────────────────────────────────────────────────┐
│ 步骤5: ⚙️ main_init执行 (系统初始化，在.text段中) 
│ 地址: 0x3E8000+ (在.text段中，具体地址由链接器决定) 
└─────────────────────────────────────────────────────────────────────────┘
│
│ 详细执行步骤:
│
│ 1. SETC OBJMODE
│ • 设置对象模式位，告诉CPU这是28x目标代码格式
│ • 影响指令解码和执行方式
│ • 必须在执行C代码前设置
│
│ 2. EALLOW (Enable Access to Protected Registers)
│ • 解锁受保护的系统寄存器
│ • 允许访问系统控制寄存器（如看门狗、时钟配置等）
│ • 这是一个安全机制，防止意外修改关键寄存器
│
│ 3. MOVZ DP, #7029h>>6
│ • 设置数据页指针(DP)
│ • 7029h是WDCR（看门狗控制寄存器）的地址
│ • >>6是因为DP寄存器只存储页号（高10位）
│ • 这样可以通过@7029h访问WDCR寄存器
│
│ 4. MOV @7029h, #0068h
│ • 写入WDCR寄存器，值0x0068
│ • 0x0068的二进制: 0000 0000 0110 1000
│ • 位15(WDDIS) = 0: 看门狗禁用位被设置
│ • 关闭看门狗，防止看门狗复位
│ • 必须在看门狗超时前完成（通常有几毫秒时间）
│
│ 5. EDIS (Disable Access to Protected Registers)
│ • 重新锁定受保护寄存器
│ • 防止后续代码意外修改系统寄存器
│
│ 6. LB _c_int00
│ • 长跳转到C运行时库的初始化函数
│ • _c_int00是TI C运行时库提供的函数
│ • 位于.text段中，由链接器链接进来
│
│ 此时状态:
│ • 看门狗已关闭（不会复位）
│ • CPU模式已设置（OBJMODE）
│ • 准备进入C运行时环境
│ • RAM还未初始化（.ebss段还是随机值）
│
▼

┌─────────────────────────────────────────────────────────────────────────┐
│ 步骤6: 🔧 _c_int00执行 (C运行时库初始化，在.text段中) 
│ 地址: 0x3E8000+ (在.text段中，TI C运行时库提供) 
│ 库文件: rts2800_ml.lib (TI提供的C运行时库) 
└─────────────────────────────────────────────────────────────────────────┘
│
│ _c_int00的详细初始化流程:
│
│ 1. 清零.ebss段（未初始化的全局变量和静态变量）:
│ • 遍历.ebss段的所有变量
│ • 将每个变量所占的内存清零
│ • 例如: int gUninitializedVar; → 内存变为0
│ • 例如: static int sStaticVar; → 内存变为0
│ • 这是C语言标准要求：未初始化变量必须为0
│ • .ebss段在.cmd文件中被分配到RAML0和RAMH0
│
│ 2. 初始化.cinit段（已初始化的全局变量）:
│ • 读取.cinit表中的初始化数据
│ • .cinit表存储在Flash中（FLASHA区域）
│ • 包含每个已初始化变量的地址和初始值
│ • 将初始值从Flash复制到RAM中的变量位置
│ • 例如: int gVar = 100; → 从.cinit表读取100，写入gVar
│ • 例如: int gArray[10] = {1,2,3...}; → 复制整个数组
│
│ 3. 调用.pinit段（构造函数和初始化函数）:
│ • 如果有C++代码，调用全局对象的构造函数
│ • 如果有IQ Math库初始化，执行相应初始化
│ • 按顺序调用所有初始化函数
│
│ 4. 设置堆栈指针(SP):
│ • 初始化SP寄存器
│ • 指向.stack段的顶部（RAMM1的末尾，0x0007FF）
│ • 堆栈向下增长（从高地址向低地址）
│ • 为函数调用和局部变量分配空间
│
│ 5. 设置其他运行时环境:
│ • 初始化C运行时库的内部数据结构
│ • 准备异常处理机制
│ • 设置浮点运算环境（如果使用）
│
│ 6. 调用main()函数:
│ • 将main()函数的地址加载到PC
│ • 跳转到main()函数开始执行
│ • 此时C环境已完全初始化
│
│ 此时状态:
│ • 所有全局变量已正确初始化
│ • 堆栈已设置，可以调用函数
│ • C运行时环境已就绪
│ • 准备执行用户程序
│
▼

┌─────────────────────────────────────────────────────────────────────────┐
│ 步骤7: 🚀 main()函数执行 (你的程序入口，在.text段中) 
│ 地址: 0x3E8000+ (在.text段中，你的C代码编译后的机器码) 
└─────────────────────────────────────────────────────────────────────────┘
│
│ main()函数的执行流程（从你的代码）:
│
│ 1. InitSysCtrl()
│ • 初始化系统控制
│ • 配置PLL（锁相环），设置CPU时钟频率
│ • 配置外设时钟分频
│ • 初始化Flash等待状态
│ • 关闭看门狗（如果之前没关闭）
│
│ 2. InitInterrupt()
│ • 初始化中断系统
│ • 配置PIE（外设中断扩展）向量表
│ • 设置中断优先级
│ • 清除所有中断标志
│ • 此时中断还未使能（EINT未执行）
│
│ 3. InitPeripherals()
│ • 初始化所有外设
│ • GPIO配置（输入/输出、上拉/下拉）
│ • PWM配置（死区时间、频率、占空比）
│ • ADC配置（采样通道、触发源）
│ • 通信接口配置（SCI、SPI、I2C、LIN等）
│ • 定时器配置
│
│ 4. InitForMotorApp()
│ • 初始化电机控制应用
│ • 配置FOC算法参数
│ • 初始化电机控制变量
│ • 设置电机控制状态机
│
│ 5. InitForFunctionApp()
│ • 初始化功能应用
│ • 配置通信协议
│ • 初始化功能模块
│
│ 6. EnableDog()
│ • 重新启用看门狗
│ • 现在系统已初始化，可以安全启用看门狗
│ • 防止程序跑飞
│
│ 7. SetInterruptEnable()
│ • 使能中断系统
│ • 允许PIE响应中断
│ • 但全局中断还未使能（EINT未执行）
│
│ 8. EINT (Enable Global Interrupt)
│ • 全局中断使能
│ • 此时CPU可以响应中断请求
│ • 中断服务程序可以执行
│
│ 9. ERTM (Enable Real-Time Debug Mode)
│ • 使能实时调试模式
│ • 允许调试器在运行时访问寄存器
│
│ 10. stimer_init() 和 stimer_addTask()
│ • 初始化软件定时器
│ • 添加定时任务（如看门狗喂狗、系统任务等）
│
│ 11. while(1) { stimer_loop(); }
│ • 进入主循环
│ • 持续执行定时任务
│ • 处理应用程序逻辑
│ • 永不返回（除非复位或错误）
│
│ 此时状态:
│ • 系统完全初始化
│ • 所有外设已配置
│ • 中断已使能
│ • 看门狗已启用
│ • 应用程序正在运行
│
▼

┌─────────────────────────────────────────────────────────────────────────┐
│ 步骤8: 🔄 主循环运行 (应用程序持续执行) 
│ 状态: 系统正常运行，响应中断，执行应用程序逻辑 
└─────────────────────────────────────────────────────────────────────────┘

═══════════════════════════════════════════════════════════════════════════
📌 关键地址总结:
═══════════════════════════════════════════════════════════════════════════

0x3FF27C → Boot ROM起始地址
• 芯片出厂时固化，不可修改
• 包含引导程序代码
• 硬件复位后强制跳转到这里

0x3F7FF6 → BEGIN地址（Flash引导入口，硬件固定）
• TI C2000 DSP硬件设计时固定
• Boot ROM会检查这个地址
• 用户不能改变这个地址
• 必须在这个地址放置code_start代码
• BEGIN只是给这个地址起的符号名

0x3E8000 → Flash存储器起始地址
• 你的程序代码存储在这里
• .text段从这里开始
• 包含所有函数：main_init, _c_int00, main(), 你的所有函数

0x3E8000+ → .text段（所有程序代码）
• main_init: 系统初始化代码
• _c_int00: C运行时库初始化代码
• main(): 你的程序入口
• 所有其他C函数
• 具体地址由链接器决定

═══════════════════════════════════════════════════════════════════════════
⚠️ 重要注意事项:
═══════════════════════════════════════════════════════════════════════════

0x3F7FF6是硬件固定地址，绝对不能改变！
• Boot ROM的代码中硬编码了这个地址
• 如果改变，Boot ROM无法找到你的程序
• BEGIN只是符号名，实际地址必须是0x3F7FF6

code_start必须放在BEGIN地址
• 链接器会将codestart段放到BEGIN地址
• code_start必须在这个段中
• 只有一条跳转指令（LB main_init）

所有实际代码都在.text段中
• main_init, _c_int00, main()都在.text段
• .text段从0x3E8000开始
• 具体函数地址由链接器决定

看门狗必须在超时前关闭
• 上电后看门狗默认使能
• 必须在几毫秒内关闭（在main_init中）
• 否则会不断复位，无法启动

RAM初始化顺序
• main_init不手动清零RAM（由_c_int00处理）
• _c_int00会自动清零.ebss段
• 已初始化变量从.cinit表加载

═══════════════════════════════════════════════════════════════════════════